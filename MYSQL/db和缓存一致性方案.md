# db和缓存一致性方案

对于读多写少并且要求高性能的业务逻辑，我们通常在应用服务器访问MySQL数据库的中间加上一层Redis缓存层，以提高数据的查询效率，减轻MySQL数据库的压力，避免在MySQL出现性能瓶颈时，影响整个系统的性能。

但是，当数据库和缓存的数据不一致时，我们如何保证读写数据时的数据一致性呢？

首先明确一点，DB和缓存时两个独立的系统组件，没有任何方案保证数据的完全的实时一致性，大部分业务场景都是容忍一定延时的数据最终一致性，因此，我们需要根据业务场景来选择合适的方案。

下面我们来介绍几种常见的解决方案。

## 1. cache Aside Pattern（缓存旁路模式）

cache Aside Pattern是一种常见的缓存一致性解决方案，它的基本思想是：

*   读取数据时：先从缓存中获取数据，如果缓存中不存在，则从数据库中获取数据，并将数据写入缓存。

*   更新数据时: 先更新db中的数据, 再删除缓存中的数据。

    **优点:**
    1\. 简单易用，实现起来比较容易。

    **缺点:**

    1.  数据不一致的情况可能会出现，特别是在高并发的情况下。例如，协程A更新了DB数据，尚未删除缓存数据，而协程B读取了缓存的旧数据，此时数据已经不一致。
    2.  缓存数据的更新和删除操作可能会失败，导致数据不一致。（删除失败可通过引入重试机制保证删除成功。）

    **适用场景:**
    1\. 数据更新频率较低，读操作较多的场景。
    2\. 数据一致性要求不高的场景。

    **需要注意的是:**
    在删除缓存数据后，如果一个key有大量请求进来，会导致缓存击穿，此时需要加分布式锁，防止大量请求穿透缓存，直接打到DB上。

## 2. 延迟双删方案

延迟双删方案是一种常见的缓存一致性解决方案，它的基本思想是：

*   读取数据时：先从缓存中获取数据，如果缓存中不存在，则从数据库中获取数据，并将数据写入缓存。

*   更新数据时: 先删除缓存中数据，再更新db中的数据, 并延迟十几毫秒(根据历史业务请求判断延迟时长)，再次删除缓存中的数据。

    **优点:**

    1.  简单易用，实现起来比较容易。

    **缺点:**

    1.  延时选择：延时时长需要根据业务场景判断，如果设置延迟过短，无法有效避免不一致的问题，如果设置过长，则会增加系统延迟。
    2.  并发问题：高并发场景无法完全避免数据不一致的问题，比如在延时期间，新请求进来查询缓存可能查到的是旧数据。
    3.  最终一致性：延时双删策略只能保证最终一致性，无法保证强一致性。
    4.  缓存数据的更新和删除操作可能会失败，导致数据不一致。（删除失败可通过引入重试机制保证删除成功。）

    **适用场景:**

    1.  数据更新频率较低，读操作较多的场景。
    2.  数据最终一致性要求高但对延时有一定容忍的场景。

## 3. Read/Write Through Pattern（读写穿透模式）

Read/Write Through Pattern 是一种缓存设计模式，其核心思想是将缓存作为数据库的代理，应用程序只与缓存服务进行交互，而缓存服务负责与数据库进行交互。其中腾讯开源的DCACHE 就是一种基于这种模式的缓存方案。

*   读取数据时：应用程序向缓存服务请求数据，缓存服务从缓存中读取数据，如果缓存中不存在，则从数据库中读取数据，并将数据写入缓存，返回数据给应用程序。
*   写入数据时：缓存服务检查缓存是否存在该数据。如果存在，则更新缓存中的数据；如果不存在，则直接更新数据库，并由缓存服务同步更新数据库中的数据‌。

    **优点:**

    1.  应用程序只需与缓存服务交互，不需要直接操作数据库，简化了代码逻辑。
    2.  由于缓存的访问速度通常比数据库快，因此可以提高数据的读取和写入速度。
    3.  对于应用程序来说，读写操作是透明的，不需要关心数据是否在缓存中存在，并发读写数据是一致性的。

    **缺点:**

    1.  需要维护一套缓存服务系统，依赖缓存服务组件与DB保持数据最终一致性，增加系统的复杂性。
    2.  ‌一致性问题‌：数据由缓存服务组件异步刷新和落库，可能会导致数据不一致的问题。
    3.  缓存服务可靠性：如果缓存服务出现故障，可能出现数据丢失。
    4.  缓存有效性管理：缓存失效时间设置过长可能导致缓存数据占用大量内存。

    **适用场景:**

    1.  虽然读写穿透模式可以减少应用程序与数据库的直接交互，但在需要严格保证数据一致性的场景中可能不是最佳选择。
    2.  对于数据一致性要求较高的场景，如金融交易、电商订单等，读写穿透模式可以提供较好的性能和数据一致性保证。
    3.  读多写少的应用场景‌：在这种模式下，读操作可以直接从缓存获取数据，写操作通过缓存代理数据库，适合读请求远多于写请求的场景。

## 4. 总结

在实际应用中，我们可以根据具体的业务场景选择合适的缓存一致性解决方案。一般来说，cache Aside Pattern 是最简单易用的方案，适用于数据更新频率较低，读操作较多的场景。如果数据一致性要求较高，并且对延时有一定容忍，那么可以选择延迟双删方案。如果需要保证数据一致性，并且对性能有较高要求，那么可以选择读写穿透模式。
在实际项目开发中，通常需要结合分布式锁解决并发读写可能带来的短暂时间内数据不一致的问题，尽最大可能保证数据一致性。
